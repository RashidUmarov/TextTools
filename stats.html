<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8"/>
    <title>HTML Stats</title>
    <!-- Общие стили сайта -->
    <link rel="stylesheet" href="styles.css">
    <!-- Специфичные стили для страницы статистики -->
    <link rel="stylesheet" href="stats.css">
</head>
<body>
<div class="header">
    <div class="inner-header">
        <div class="logo-container">
            <h1>HTML Stats</h1>
        </div>
        <nav class="navigation">
            <ul>
                <li><a href="stats.html">Stats</a></li>
                <li><a href="sizer.html">Sizer</a></li>
                <li><a href="link_dropper.html">Dropper</a></li>
                <li><a href="code_blocks.html">Blocks</a></li>
                <li><a href="changer.html">Changer</a></li>
                <li><a href="composer.html">Composer</a></li>
                <li><a href="cleaner.html">Cleaner</a></li>
                <li><a href="index.html">About</a></li>
            </ul>
        </nav>
    </div>
</div>

<div class="content">
    <div id="drop_zone">Перетащите сюда файл</div>
    <div id="file_contents">Здесь появится содержимое файла…</div>
    <div id="link_blocks"></div>
    <!-- Блок для статистики кириллицы -->
    <div id="cyrillic_stats" style="margin-top: 1em;
                                       padding: 0.5em;
                                       border: 1px solid #ccc; display:none;
                                       "></div>
    <button id="reset_button" class="btn-look">Сбросить</button>
</div>

<script>
    const dropZone = document.getElementById('drop_zone');
    const output = document.getElementById('file_contents');
    const resetButton = document.getElementById('reset_button');
    const linkBlocks = document.getElementById('link_blocks');
    const statsBlock = document.getElementById('cyrillic_stats');

    // Поведение drag & drop
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        dropZone.addEventListener(evt, e => e.preventDefault());
        document.body.addEventListener(evt, e => e.preventDefault());
    });

    dropZone.addEventListener('dragover', () => {
        dropZone.classList.add('hover');
        dropZone.textContent = 'Отпустите файл';
    });
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('hover');
        dropZone.textContent = 'Перетащите сюда файл';
    });

    /*  формируем таблицу статистики */
function appendStatsToPage(wordsCount, charsCount, filename) {
  let wrapper = document.querySelector('.table-wrapper');
  let table = document.querySelector('table.standart');

  // Найдём контейнер .content (гарантированно есть)
  const content = document.querySelector('.content');

  // Если таблицы нет — создаём обёртку и таблицу
  if (!table) {
    wrapper = document.createElement('div');
    wrapper.className = 'table-wrapper';

    table = document.createElement('table');
    table.className = 'standart';
    table.style.minWidth = '1200px';
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';

    const thead = document.createElement('thead');
    thead.innerHTML = `
      <tr>
        <th>#</th>
        <th>Type</th>
        <th>File</th>
        <th>Size (bytes)</th>
        <th>Characters</th>
        <th>Words</th>
        <th>Pages</th>
        <th>Aver. Length</th>
      </tr>
    `;
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    table.appendChild(tbody);

    wrapper.appendChild(table);
    content.appendChild(wrapper); // <== ВСТАВЛЯЕМ В content, не в body
  }

  const tbody = table.querySelector('tbody');
  const newRow = document.createElement('tr');
  const index = tbody.querySelectorAll('tr').length + 1;

  const pages = (charsCount / 1800).toFixed(2);
  const averageLength = wordsCount > 0 ? (charsCount / wordsCount).toFixed(1) : '–';

  newRow.innerHTML = `
    <td align="center">${index}</td>
    <td>HTML</td>
    <td>${filename}</td>
    <td align="center">–</td>
    <td align="center">${charsCount.toLocaleString()}</td>
    <td align="center">${wordsCount.toLocaleString()}</td>
    <td align="center">${pages}</td>
    <td align="center">${averageLength}</td>
  `;

  tbody.appendChild(newRow);
}



    // Функция подсчёта слов и символов на кириллице, исключая блок #announce
    function calculateCyrillicStats(html) {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        // Удаляем блок анонса, если он есть
        const announceEl = doc.getElementById('announce');
        if (announceEl) announceEl.remove();
        // Берём текст всего тела документа без #announce
        const text = doc.body.textContent || '';
        // Ищем слова только из кириллицы
        const matches = text.match(/[А-ЯЁа-яё]+/g) || [];
        const wordsCount = matches.length;
        const charsCount = matches.reduce((sum, w) => sum + w.length, 0);
        return {wordsCount, charsCount};
    }

    function calculateRussianSymbolsFromHtml(html) {
        // 1. Разобрать HTML
        const doc = new DOMParser().parseFromString(html, 'text/html');

        // 2. Удалить блок #announce, если есть
        const announceEl = doc.getElementById('announce');
        if (announceEl) announceEl.remove();

        // 3. Извлечь текст из body и title
        const text =
            (doc.title ? doc.title + ' ' : '') +
            (doc.body?.textContent || '');
        console.log('Извлечённый текст:', text);
        console.log('Пример поиска вручную:');
        console.log(text.match(/[а-яА-ЯёЁ]{3,}/g)?.slice(0, 10));

        // 4. Применить регулярку, как в Java-алгоритме
        /*const rusWordRegex = /\b\w*?[а-яА-ЯёЁ]+?\w*?\b/g;*/
        /*const rusWordRegex = /[а-яА-ЯёЁ]{2,}/g;*/
        const rusWordRegex = /[a-zA-Zа-яА-ЯёЁ0-9_]*[а-яА-ЯёЁ]+[a-zA-Zа-яА-ЯёЁ0-9_]*/g;
        const matches = text.match(rusWordRegex) || [];

        console.log('Всего совпадений:', matches.length);
        console.log('Первое слово:', matches[0]);
        console.log('Пример суммирования длины:', matches.slice(0, 5).map(w => `${w} (${w.length})`));

        const charsCount = matches.reduce((sum, word) => sum + word.length, 0);
        const wordsCount = matches.length;

// Сохраняем все найденные слова в файл RUS_JS_words_<rand>.csv
        const rand = Math.floor(Math.random() * 100) + 1;
        const filename = `RUS_words_${rand}.csv`;
        const csvContent = "Word\n" + matches.join("\n");

        const blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        return {charsCount, wordsCount};
    }


    dropZone.addEventListener('drop', e => {
        dropZone.classList.remove('hover');
        dropZone.textContent = 'Файл получен!';
        const file = e.dataTransfer.files[0];
        if (!file || !file.type.match('text.*')) {
            output.textContent = 'Пожалуйста, перетащите текстовый файл.';
            return;
        }
        const reader = new FileReader();
        reader.onload = ev => {
            const html = ev.target.result;
            const {title, description, announce} = extractArticleInfo(html);
            const links = extractCategoryLinks(html);

            // Вывод заголовка, описания и анонса
            output.innerHTML =
                `<h2>${title}</h2>` +
                `<div class="styled-block"><p>${description}</p></div>` +
                `<div>${announce}</div>`;

            // Отрисовка блоков ссылок
            renderCategoryBlocks('link_blocks', links);

            // Подсчёт и вывод статистики кириллицы, без #announce
            /*const stats = calculateCyrillicStats(html);*/
            const stats = calculateRussianSymbolsFromHtml(html);
            statsBlock.style.display = 'block';
            statsBlock.innerHTML = `
          <h3>Статистика кириллических слов</h3>
          <p>Количество слов: ${stats.wordsCount}</p>
          <p>Количество символов: ${stats.charsCount}</p>
        `;

            const filename = file.name;
            appendStatsToPage(stats.wordsCount, stats.charsCount, filename);

            resetButton.style.display = 'block';
        };

        reader.onerror = () => {
            output.textContent = 'Ошибка при чтении файла.';
        };
        reader.readAsText(file, 'UTF-8');
    });

    resetButton.addEventListener('click', () => {
        output.textContent = 'Здесь появится содержимое файла…';
        dropZone.textContent = 'Перетащите сюда файл';
        resetButton.style.display = 'none';
        linkBlocks.innerHTML = '';
        statsBlock.style.display = 'none';

        // Удаляем таблицу статистики, если есть
        const statsWrapper = document.querySelector('.table-wrapper');
        if (statsWrapper) statsWrapper.remove();
    });

    function extractArticleInfo(html) {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        return {
            title: doc.querySelector('title')?.textContent.trim() || 'Нет заголовка',
            description: doc.querySelector('#description')?.textContent.trim() || 'Нет описания',
            announce: doc.querySelector('#announce')?.innerHTML.trim() || 'Нет анонса'
        };
    }

    function extractCategoryLinks(html) {
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const anchors = Array.from(doc.querySelectorAll('a[href]'));
        const categories = {articles: [], code: [], docs: [], metatrader5: [], other: []};
        anchors.forEach(a => {
            const href = a.getAttribute('href');
            if (/\/articles\//.test(href)) categories.articles.push(href);
            else if (/\.mql5\.com\/.*\/code/.test(href)) categories.code.push(href);
            else if (/\/docs\//.test(href)) categories.docs.push(href);
            else if (/metaquotes\.net/.test(href)) categories.metatrader5.push(href);
            else if (/metatrader5\.com/.test(href)) categories.metatrader5.push(href);
            else categories.other.push(href);
        });
        return categories;
    }

    function renderCategoryBlocks(containerId, categories) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        Object.entries(categories).forEach(([key, links]) => {
            if (links.length === 0) return; // пропустить пустые категории

            const block = document.createElement('div');
            block.className = 'styled-block';
            const title = document.createElement('h3');
            title.textContent = `${key.charAt(0).toUpperCase() + key.slice(1)} (${links.length})`;
            const list = document.createElement('ul');
            links.forEach(link => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = link;
                a.textContent = link;
                a.target = '_blank';
                li.appendChild(a);
                list.appendChild(li);
            });
            block.append(title, list);
            container.appendChild(block);
        });
    }
</script>
</body>
</html>
